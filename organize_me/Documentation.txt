Summary of Project:

	This project is to create a application that will help simplify and streamline organization by combining
calendars and reminders (along with some other functions like recuring payments and bills) so that people can get their life in order.  You can also
add recuring payments that you may have, and the algorithm will properly give you notifications to let you know when
a payment is upcoming so you don't get suprised and are able to budget your life better.


To do:

Sprint One: Create Layout

1. Pages: Home/Customize/Settings
2. Create Cards and Layouts for each page *each will be subject to change*
3. Implement Calendar API and set up layouts for each function

Page 1: Home (DONE)
	- This will hold the information that the user will be looking for, should be mostly a static page
Page 2: Customization Page (CURRENTLY WORKING ON)
	- This page will be updating and adding to the Home Page.  Add dates, reminders, and payments
Page 3: Settings Page
	- Show the user their information
	- Log out Button
Login Page:
	- Ask user to enter their information
	- Allow people to create a new account

Sprint 2: Functionality

Home Page and Cards:
	Calendar:
		- Make a way for people to add things to the calendar
		- Make different types of icons for calendar events

	Reminders:
		- Sync with the Calendar to show upcoming events and things to do

	Bills/Payments:
		- Manually Log different Payments that you have *don't want to sync with any real card because security*
		- Create the best algorithm to figure out when payments will be due
		- Send notifications for when a payment is coming up

Customize Page:
	- Have buttons to create new dates, reminders, and payments
	- When a new event is created, it should sync it accross all or at least display properly
	
Settings:
	- Have user information and account information
	-

Sprint 3: User friednly implementations
	- Allow people to sync their Google Calendar/possible iOS calendar as well
	- Allow people to customize the Home Page
	- Some type of log in method (probably firebase)


Temp Code:

 Widget build(BuildContext context) {
    return WillPopScope(
      child: Container(
        child: SafeArea(
          child: Scaffold(
            body: SingleChildScrollView(
              child: Container(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    // THIS IS THE TOP WIDGET FOR THE CALENDAR
                    Container(
                      child: DesignCard(
                        child: Column(
                          children: <Widget>[
                            TableCalendar(
                              calendarStyle: CalendarStyle(
                                todayColor: Colors.blue[600],
                                selectedColor: Colors.blue[900],
                              ),
                              calendarController: _calendarController,
                            )
                          ],
                        ),
                      ),
                    ),


                    // SECOND WIDGET FOR THE REMINDERS
                    DesignCard(
                      child: Row(
                        children: <Widget>[
                          Flexible(
                            child: Container(
                              width: 1000,
                              child: SmallDesignCard(
                                child: Column(
                                  children: <Widget>[
                                    Text(
                                      "Reminder 1"
                                    )
                                  ],
                                ),
                              ),
                            ),
                          ),
                          Flexible(
                            child: Container(
                              width: 1000,
                              child: SmallDesignCard(
                                child: Column(
                                  children: <Widget>[
                                    Text(
                                      "Reminder 2"
                                    )
                                  ],
                                ),
                              ),
                            ),
                          ),
                          Flexible(
                            child: Container(
                              width: 1000,
                              child: SmallDesignCard(
                                child: Column(
                                  children: <Widget>[
                                    Text(
                                      "Reminder 3"
                                    )
                                  ],
                                ),
                              ),
                            ),
                          ),
                          Flexible(
                            child: Container(
                              width: 1000,
                              child: SmallDesignCard(
                                child: Column(
                                  children: <Widget>[
                                    Text(
                                      "Reminder 4"
                                    )
                                  ],
                                ),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),


                    // THIRD WIDGET FOR THE UPCOMMING PAYMENTS
                    DesignCard(
                      child: Column(
                        children: <Widget>[
                          
                        ],
                      ),
                    )
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
      onWillPop: () async => true,
    );
  }



@override
  Widget build (BuildContext context) {
    return WillPopScope(
      child: ExpandableTheme(
        data:
          const ExpandableThemeData(
            iconColor: Colors.blue,
            useInkWell: true,
          ),
        child: ListView(
          physics: const BouncingScrollPhysics(),
          children: <Widget>[
            Calendar(),
            Reminders(),
            Bills(),
          ],
        ),
      ),
    );
  }
}

List<ItemData> _items;
  _CustomizePageState() {
    _items = List();
    for (int i = 0; i < 3; ++i) {
      String label = "List item $i";
      if (i == 5) {
        label += ". This item has a long label and will be wrapped.";
      }
      _items.add(ItemData(label, ValueKey(i)));
    }
  }

  // Returns index of item with given key
  int _indexOfKey(Key key) {
    return _items.indexWhere((ItemData d) => d.key == key);
  }

  bool _reorderCallback(Key item, Key newPosition) {
    int draggingIndex = _indexOfKey(item);
    int newPositionIndex = _indexOfKey(newPosition);

    // Uncomment to allow only even target reorder possition
    // if (newPositionIndex % 2 == 1)
    //   return false;

    final draggedItem = _items[draggingIndex];
    setState(() {
      debugPrint("Reordering $item -> $newPosition");
      _items.removeAt(draggingIndex);
      _items.insert(newPositionIndex, draggedItem);
    });
    return true;
  }

  void _reorderDone(Key item) {
    final draggedItem = _items[_indexOfKey(item)];
    debugPrint("Reordering finished for ${draggedItem.title}}");
  }

  //
  // Reordering works by having ReorderableList widget in hierarchy
  // containing ReorderableItems widgets
  //

  DraggingMode _draggingMode = DraggingMode.iOS;

  Widget build(BuildContext context) {
    return Scaffold(
      body: ReorderableList(
        onReorder: this._reorderCallback,
        onReorderDone: this._reorderDone,
        // decoratePlaceholder: (Widget item, double opacity) {
        // return DecoratedPlaceholder(widget: item, offset: 0);
        // },
        child: Column(
          children: <Widget>[
            DesignCard(
              child: Text("Top Card"),
            ),
            Container(
              child: ListView.builder(
                  itemBuilder: (BuildContext context, int index) {
                return Item(
                  data: _items[index],
                  isFirst: index == 0,
                  isLast: index == _items.length - 1,
                  draggingMode: _draggingMode,
                );
              }),
            )
          ],
        ),
      ),
    );
  }


class Item extends StatelessWidget {
  Item({
    this.data,
    this.isFirst,
    this.isLast,
    this.draggingMode,
  });

  final ItemData data;
  final bool isFirst;
  final bool isLast;
  final DraggingMode draggingMode;

  Widget _buildChild(BuildContext context, ReorderableItemState state) {
    BoxDecoration decoration;

    if (state == ReorderableItemState.dragProxy ||
        state == ReorderableItemState.dragProxyFinished) {
      // slightly transparent background white dragging (just like on iOS)
      decoration = BoxDecoration(color: Color(0xD0FFFFFF));
    } else {
      bool placeholder = state == ReorderableItemState.placeholder;
      decoration = BoxDecoration(
          border: Border(
              top: isFirst && !placeholder
                  ? Divider.createBorderSide(context) //
                  : BorderSide.none,
              bottom: isLast && placeholder
                  ? BorderSide.none //
                  : Divider.createBorderSide(context)),
          color: placeholder ? null : Colors.white);
    }

    // For iOS dragging mode, there will be drag handle on the right that triggers
    // reordering; For android mode it will be just an empty container
    Widget dragHandle = draggingMode == DraggingMode.iOS
        ? ReorderableListener(
            child: Container(
              padding: EdgeInsets.only(right: 18.0, left: 18.0),
              color: Color(0x08000000),
              child: Center(
                child: Icon(Icons.reorder, color: Color(0xFF888888)),
              ),
            ),
          )
        : Container();

    Widget content = Container(
      decoration: decoration,
      child: SafeArea(
          top: false,
          bottom: false,
          child: Opacity(
            // hide content for placeholder
            opacity: state == ReorderableItemState.placeholder ? 0.0 : 1.0,
            child: IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: <Widget>[
                  Expanded(
                      child: Padding(
                    padding:
                        EdgeInsets.symmetric(vertical: 14.0, horizontal: 14.0),
                    child: Text(data.title,
                        style: Theme.of(context).textTheme.subtitle1),
                  )),
                  // Triggers the reordering
                  dragHandle,
                ],
              ),
            ),
          )),
    );

    // For android dragging mode, wrap the entire content in DelayedReorderableListener
    if (draggingMode == DraggingMode.Android) {
      content = DelayedReorderableListener(
        child: content,
      );
    }

    return content;
  }

  @override
  Widget build(BuildContext context) {
    return ReorderableItem(
        key: data.key, //
        childBuilder: _buildChild);
  }
}